<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blockchain Hashing Practical Training</title>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    button { margin: 10px 0; padding: 10px 20px; font-size: 16px; }
    #chain { white-space: pre-wrap; background: #f4f4f4; padding: 15px; border: 1px solid #ddd; max-height: 400px; overflow-y: auto; }
</style>
</head>
<body>
<h1>Blockchain Hashing Practical Training</h1>

<button id="addBlockBtn">Add New Block</button>
<button id="validateBtn">Validate Blockchain</button>

<h2>Blockchain Data</h2>
<div id="chain">Loading blockchain...</div>
<h2>Status</h2>
<div id="status"></div>

<script>
class Block {
    constructor(index, timestamp, data, previousHash = '') {
        this.index = index;
        this.timestamp = timestamp;
        this.data = data;
        this.previousHash = previousHash;
        this.nonce = 0;
        this.hash = '';
    }

    async calculateHash() {
        const msg = this.index + this.timestamp + JSON.stringify(this.data) + this.previousHash + this.nonce;
        const msgBuffer = new TextEncoder().encode(msg);
        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async mineBlock(difficulty) {
        const target = '0'.repeat(difficulty);
        do {
            this.nonce++;
            this.hash = await this.calculateHash();
        } while(this.hash.substring(0, difficulty) !== target);
        return this.hash;
    }
}

class Blockchain {
    constructor() {
        this.chain = [];
        this.difficulty = 3;
        this.initChain();
    }

    async initChain() {
        const genesisBlock = new Block(0, new Date().toISOString(), "Genesis Block", "0");
        await genesisBlock.mineBlock(this.difficulty);
        this.chain.push(genesisBlock);
        this.displayChain();
    }

    getLatestBlock() {
        return this.chain[this.chain.length - 1];
    }

    async addBlock(newData) {
        const newIndex = this.chain.length;
        const newBlock = new Block(newIndex, new Date().toISOString(), newData, this.getLatestBlock().hash);
        await newBlock.mineBlock(this.difficulty);
        this.chain.push(newBlock);
        this.displayChain();
    }

    async isChainValid() {
        for(let i = 1; i < this.chain.length; i++) {
            const currentBlock = this.chain[i];
            const previousBlock = this.chain[i - 1];
            const calculatedHash = await currentBlock.calculateHash();

            if(currentBlock.hash !== calculatedHash) {
                return false;
            }
            if(currentBlock.previousHash !== previousBlock.hash) {
                return false;
            }
        }
        return true;
    }

    displayChain() {
        const chainDiv = document.getElementById('chain');
        chainDiv.textContent = JSON.stringify(this.chain, null, 4);
    }
}

const blockchain = new Blockchain();

document.getElementById('addBlockBtn').addEventListener('click', async () => {
    const amount = prompt("Enter some data for the block (e.g. amount):", "10");
    if(amount != null) {
        await blockchain.addBlock({ amount: amount });
        document.getElementById('status').textContent = 'New block added and mined.';
    }
});

document.getElementById('validateBtn').addEventListener('click', async () => {
    const valid = await blockchain.isChainValid();
    document.getElementById('status').textContent = valid ? 'Blockchain is valid.' : 'Blockchain has been tampered!';
});
</script>

</body>
</html>
