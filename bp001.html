<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>SHA-256 해시 함수 테스트 - 난이도 선택 가능</title>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    input, label, button, select { font-size: 16px; padding: 8px; margin-top: 10px; width: 100%; max-width: 400px; }
    #hashOutput, #status { margin-top: 20px; padding: 10px; background: #f0f0f0; border: 1px solid #ccc; word-break: break-all; }
    .row { margin-bottom: 10px; }
    button { cursor: pointer; }
</style>
</head>
<body>
<h1>SHA-256 해시 함수 테스트</h1>
<div class="row">
  <label for="inputText">입력값 :</label>
  <input type="text" id="inputText" placeholder="여기에 메시지를 입력하세요" autocomplete="off" />
</div>
<div class="row">
  <label for="nonceInput">Nonce 값 :</label>
  <input type="number" id="nonceInput" value="0" min="0" />
</div>
<div class="row">
  <label for="difficultySelect">난이도 선택 (해시 시작값):</label>
  <select id="difficultySelect">
    <option value="000">000</option>
    <option value="0000">0000</option>
    <option value="00000">00000</option>
  </select>
</div>
<button id="findNonceBtn">해시 시작값에 맞는 Nonce 찾기</button>
<h2>해시 결과</h2>
<div id="hashOutput">해시 값이 여기에 표시됩니다</div>
<h2>상태</h2>
<div id="status"></div>

<script>
async function sha256(message) {
    const msgBuffer = new TextEncoder().encode(message);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

async function updateHash() {
    const input = document.getElementById('inputText').value;
    const nonce = document.getElementById('nonceInput').value;
    const combined = input + nonce;
    const hash = await sha256(combined);
    document.getElementById('hashOutput').textContent = hash;
}

document.getElementById('findNonceBtn').addEventListener('click', async () => {
    const input = document.getElementById('inputText').value;
    const difficulty = document.getElementById('difficultySelect').value;
    if (input === '') {
        alert('먼저 입력값을 입력해주세요!');
        return;
    }

    document.getElementById('status').textContent = `Nonce 찾는 중... 시작값: '${difficulty}' 잠시만 기다려주세요.`;
    let nonce = 0;

    while(true) {
        const combined = input + nonce;
        const hash = await sha256(combined);
        if(hash.startsWith(difficulty)) {
            document.getElementById('nonceInput').value = nonce;
            document.getElementById('hashOutput').textContent = hash;
            document.getElementById('status').textContent = `해시 시작값 '${difficulty}' 조건에 맞는 nonce 찾음: ${nonce}`;
            break;
        }
        nonce++;
        if(nonce % 1000 === 0) await new Promise(r => setTimeout(r, 0));
    }
});

document.getElementById('inputText').addEventListener('input', updateHash);
document.getElementById('nonceInput').addEventListener('input', updateHash);

window.addEventListener('DOMContentLoaded', updateHash);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Blockchain Hashing Practical Training</title>
<style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    button { margin: 10px 0; padding: 10px 20px; font-size: 16px; }
    #chain { white-space: pre-wrap; background: #f4f4f4; padding: 15px; border: 1px solid #ddd; max-height: 400px; overflow-y: auto; }
</style>
</head>
<body>
<h1>Blockchain Hashing Practical Training</h1>

<button id="addBlockBtn">Add New Block</button>
<button id="validateBtn">Validate Blockchain</button>

<h2>Blockchain Data</h2>
<div id="chain">Loading blockchain...</div>
<h2>Status</h2>
<div id="status"></div>

<script>
class Block {
    constructor(index, timestamp, data, previousHash = '') {
        this.index = index;
        this.timestamp = timestamp;
        this.data = data;
        this.previousHash = previousHash;
        this.nonce = 0;
        this.hash = '';
    }

    async calculateHash() {
        const msg = this.index + this.timestamp + JSON.stringify(this.data) + this.previousHash + this.nonce;
        const msgBuffer = new TextEncoder().encode(msg);
        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async mineBlock(difficulty) {
        const target = '0'.repeat(difficulty);
        do {
            this.nonce++;
            this.hash = await this.calculateHash();
        } while(this.hash.substring(0, difficulty) !== target);
        return this.hash;
    }
}

class Blockchain {
    constructor() {
        this.chain = [];
        this.difficulty = 3;
        this.initChain();
    }

    async initChain() {
        const genesisBlock = new Block(0, new Date().toISOString(), "Genesis Block", "0");
        await genesisBlock.mineBlock(this.difficulty);
        this.chain.push(genesisBlock);
        this.displayChain();
    }

    getLatestBlock() {
        return this.chain[this.chain.length - 1];
    }

    async addBlock(newData) {
        const newIndex = this.chain.length;
        const newBlock = new Block(newIndex, new Date().toISOString(), newData, this.getLatestBlock().hash);
        await newBlock.mineBlock(this.difficulty);
        this.chain.push(newBlock);
        this.displayChain();
    }

    async isChainValid() {
        for(let i = 1; i < this.chain.length; i++) {
            const currentBlock = this.chain[i];
            const previousBlock = this.chain[i - 1];
            const calculatedHash = await currentBlock.calculateHash();

            if(currentBlock.hash !== calculatedHash) {
                return false;
            }
            if(currentBlock.previousHash !== previousBlock.hash) {
                return false;
            }
        }
        return true;
    }

    displayChain() {
        const chainDiv = document.getElementById('chain');
        chainDiv.textContent = JSON.stringify(this.chain, null, 4);
    }
}

const blockchain = new Blockchain();

document.getElementById('addBlockBtn').addEventListener('click', async () => {
    const amount = prompt("Enter some data for the block (e.g. amount):", "10");
    if(amount != null) {
        await blockchain.addBlock({ amount: amount });
        document.getElementById('status').textContent = 'New block added and mined.';
    }
});

document.getElementById('validateBtn').addEventListener('click', async () => {
    const valid = await blockchain.isChainValid();
    document.getElementById('status').textContent = valid ? 'Blockchain is valid.' : 'Blockchain has been tampered!';
});
</script>

</body>
</html>

